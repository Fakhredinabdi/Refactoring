# SE_LAB_7
## 99106458 - 99101921

<div dir="rtl" align="right">

## توضیح الگوهای طراحی استفاده شده

- **الگوی State-Strategy**  
این الگوها به شما اجازه می‌دهند بدون تغییر کد کلاینت، رفتار یا منطق اجرایی یک شی را در زمان اجرا تغییر دهید. در الگوی State، وضعیت داخلی شی مشخص می‌کند که کدام رفتار فعال باشد و شی می‌تواند به حالت‌های مختلف سوئیچ کند. در الگوی Strategy، چند نوع رفتار در قالب کلاس‌های جدا تعریف و هر بار یکی از آن‌ها انتخاب و تزریق می‌شود.

- **الگوی Seperate Query from modifier**  
این الگو تاکید دارد که متدهای کلاس یا فقط باید داده را به صورت readonly بازیابی کنند (Query) یا فقط داده را تغییر دهند (Modifier). ترکیب این دو در یک متد باعث پیچیدگی و احتمال بروز باگ می‌شود. این جداسازی موجب افزایش خوانایی، تست‌پذیری و جلوگیری از تغییرات ناخواسته در داده‌ها می‌شود.

- **الگوی Encapsulate Collection**  
در این الگو مجموعه‌ها (مثل آرایه‌ها یا لیست‌ها) private تعریف شده و عملیات‌هایی مثل افزودن یا حذف عضو فقط از طریق متدهای کنترل شده انجام می‌شود. با این کار می‌توان اعتبارسنجی، مدیریت رویداد و اعمال قوانین بیزینسی را هنگام تغییر کلکشن تضمین کرد و همچنین وابستگی به ساختار داخلی مجموعه را کاهش داد.

- **الگوی Extract Method**  
کدهای طولانی یا پیچیده که وظیفه‌ای مستقل دارند، در متدهای کوچک‌تر و با نام مناسب قرار می‌گیرند. این کار به توزیع مسئولیت در کد، افزایش خوانایی و ساده شدن رفع اشکال و تغییرات بعدی کمک می‌کند. همچنین قابلیت استفاده مجدد و تست‌پذیری را بالا می‌برد.

- **الگوی Self-Encapsulated Field**  
در این تکنیک، فیلدهای داخلی کلاس فقط از طریق متدهای getter و setter دسترسی‌پذیر هستند. این موضوع امکان پیاده‌سازی منطق اضافی مانند اعتبارسنجی، lazy loading یا مدیریت رویداد هنگام دریافت یا تنظیم مقدار فیلد را فراهم می‌کند و از تغییر غیرمجاز داده‌ها جلوگیری خواهد کرد.

- **الگوی Facade**  
Facade یک اینترفیس ساده و سطح بالاتری برای مجموعه‌ای از کلاس‌ها و زیرسیستم‌های پیچیده فراهم می‌کند. کاربر یا کلاینت فقط با کلاس Facade کار می‌کند و تعامل با اجزای داخلی و جزئیات پیاده‌سازی برای او مخفی می‌ماند. این کار باعث کاهش وابستگی، ساده‌سازی استفاده و مدیریت راحت‌تر تغییرات سیستم می‌شود.


## پاسخ‌ها به سوالات

۱. هر یک از مفاهیم زیر را در حد یک خط توضیح دهید.

- **کد تمیز:**  
کدی است که خوانا، قابل فهم، ساده و بدون ابهام نوشته شده باشد تا نگهداری و توسعه آن آسان باشد.

- **بدهی فنی:**  
اشاره به تصمیمات سریع یا کدهای ناقصی دارد که به منظور تسریع کار نوشته شده و در آینده نیاز به اصلاح دارد.

- **بوی بد:**  
به نشانه‌ها یا الگوهای مشکل‌ساز در کد گفته می‌شود که نشان می‌دهند ساختار کد نیاز به بازنگری یا بهبود دارد.

---

۲. طبق دسته‌بندی وبسایت [refactoring.guru](https://refactoring.guru)، بوی‌های بد کد به پنج دسته تقسیم می‌شوند. در مورد هر کدام از این پنج دسته توضیح مختصری دهید.

- **Bloaters:**  
کلاس‌ها، متدها یا آرایه‌هایی که بیش از حد بزرگ یا پیچیده شده‌اند و نیازمند کوچک‌سازی و ساده‌سازی هستند.

- **Object-Orientation Abusers:**  
مواردی که اصول شیء‌گرایی مانند وراثت و پلی‌مورفیسم به درستی رعایت نشده‌اند، مثلاً استفاده افراطی از وراثت یا عدم کپسوله‌سازی.

- **Change Preventers:**  
ساختارهایی که اعمال تغییرات را سخت یا زمان‌بر می‌کنند، مثلاً باید چند جای مختلف را همزمان تغییر دهید.

- **Couplers:**  
کلاس‌ها یا متدهایی که بیش از حد به هم وابسته‌اند و استقلال کافی ندارند.

- **Dispensables:**  
کدهایی که حضورشان ضرورتی ندارد یا می‌توان بدون آن‌ها کارایی و خوانایی کد را حفظ کرد، مانند کدهای تکراری یا کامنت‌های بیهوده.


Feature Envy در دسته Couplers یا وابستگی زیاد قرار می‌گیرد، زیرا یک کلاس یا متد بیش از حد به داده‌های کلاس دیگر وابسته است.

- برای برطرف کردن این بو، استفاده از کدام بازآرایی‌ها پیشنهاد می‌شود؟  
بازآرایی‌هایی مانند Move Method یا Extract Method برای کاهش این وابستگی شدید پیشنهاد می‌شوند.

- در چه مواقعی باید این بو را نادیده گرفت؟  
زمانی که وابستگی به یک کلاس دیگر، از نظر معماری یا دامنه مسئله اجتناب‌ناپذیر باشد و جابجایی منطق باعث پیچیده‌تر شدن ساختار پروژه شود می‌توان این بو را نادیده گرفت.

---
</div>
<div dir="rtl" align="right">

۴. 
- Bug به معنی رفتار نادرست و خطا در اجرای کد است، اما Code Smell نشانه‌ای از ضعف طراحی یا ساختار است که شاید هنوز باعث خطا نشده باشد.
- Bug نیازمند اصلاح اضطراری است چون به عملکرد نرم‌افزار لطمه می‌زند، اما Code Smell معمولاً بازآرایی و بهبود (Refactor) را ضروری می‌کند تا کیفیت کد در آینده حفظ شود.

---

<div dir="rtl" align="right">
۵ - 
۱. **Long Method:**  
در فایل `src/model/Model.c`، متدهایی مانند `convert_class_to_c` بسیار طولانی و دارای منطق پیچیده‌اند.

۲. **Large Class:**  
کلاس‌هایی مانند `Model` و `Parser` (در فایل‌های `src/model/Model.c` و `src/parser/Parser.c`) وظایف متعدد دارند و بیش از حد بزرگ شده‌اند.

۳. **Duplicate Code:**  
در تولید کد بخش‌های مختلف، کدهای تکراری مثل تولید header یا footer در فایل‌هایی مانند `src/codegen/ClassCodeGen.c` و بخش‌های دیگر codegen تکرار شده‌اند.

۴. **Data Clumps:**  
پارامترهای تکراری و وابسته مانند `name, type, visibility` در توابع مختلف (به ویژه بخش تولید کد کلاس) مشاهده می‌شود.

۵. **Feature Envy:**  
برخی متدها بیشترین استفاده را از داده‌ها و متدهای کلاس‌های دیگر دارند (مثلاً در تبدیل ارتباطات کلاس‌ها در ماژول Model).

۶. **Primitive Obsession:**  
در بخش‌های مختلف پروژه، استفاده زیاد از انواع داده‌ای ساده (مثل `char*`، `int`) بجای نوع‌های ساختارمند دیده می‌شود.

۷. **Long Parameter List:**  
توابعی مانند بعضی متدهای `CodeGen.c` دارای تعداد زیادی پارامتر هستند.

۸. **Switch Statements:**  
در بخش‌هایی مثل تبدیل نوع وابستگی کلاس‌ها، از switch‌های متعدد برای وضعیت‌های مختلف استفاده شده است.

۹. **Comments:**  
در بسیاری از فایل‌ها، (مثل `src/codegen`) توضیحات طولانی برای هر تابع آورده شده که گاهی افراطی است.

۱۰. **Speculative Generality:**  
برخی توابع و ساختارها هنوز استفاده نشده‌اند یا برای توسعه آتی در نظر گرفته شده‌اند (مانند اینترفیس‌ها و enumها در ساختار پروژه).
</div>
---

۶ - 
پلاگین formatter به صورت خودکار کد شما را طبق یک سبک مشخص (code style) قالب‌بندی و یکنواخت می‌کند؛ این پلاگین در پروژه‌های Maven نقش مهمی در خوانایی و نگهداری راحت‌تر کد دارد و از ایجاد اختلاف‌های سطحی در commit جلوگیری می‌کند. اگرچه formatter خودش بازآرایی نیست، اما کد را برای بازآرایی آماده‌تر و خوانایی تغییرات بعدی را ساده‌تر می‌کند.


